apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init
  namespace: vault
spec:
  template:
    spec:
      serviceAccountName: vault
      restartPolicy: OnFailure
      containers:
      - name: vault-init
        image: hashicorp/vault:1.15.2
        env:
        - name: VAULT_ADDR
          value: "http://vault:8200"
        - name: AWS_REGION
          value: "us-east-1"
        command:
        - /bin/sh
        - -c
        - |
          # Wait for Vault to be ready
          until vault status >/dev/null 2>&1 || [ $? -eq 2 ]; do 
            sleep 5
          done
          
          # Initialize Vault if not already initialized
          if ! vault status 2>/dev/null | grep -q "Initialized.*true"; then
            echo "Initializing Vault..."
            vault operator init -recovery-shares=1 -recovery-threshold=1 > /tmp/init-output
            echo "Vault initialized successfully"
          fi
          
          # Wait for auto-unsealing
          TIMEOUT=180
          ELAPSED=0
          until vault status 2>/dev/null | grep -q "Sealed.*false"; do 
            [ $ELAPSED -ge $TIMEOUT ] && exit 1
            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done
          
          # Get root token from initialization output or use existing
          if [ -f /tmp/init-output ]; then
            export VAULT_TOKEN=$(grep 'Initial Root Token:' /tmp/init-output | awk '{print $NF}')
          else
            echo "Vault already initialized, need existing root token"
            # In production, this should be handled differently
            exit 0
          fi
          
          # Enable Kubernetes auth method
          vault auth enable kubernetes 2>/dev/null || echo "Kubernetes auth already enabled"
          
          # Configure Kubernetes auth
          vault write auth/kubernetes/config \
            kubernetes_host="https://kubernetes.default.svc.cluster.local:443" \
            token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
            kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          

          
          # Create policy for application secrets
          vault policy write app-secrets-read - <<EOF
          path "secret/data/*" {
            capabilities = ["read"]
          }
          path "secret/metadata/*" {
            capabilities = ["read"]
          }
          EOF
          
          # Create role for external-secrets (Kubernetes auth)
          vault write auth/kubernetes/role/external-secrets \
            bound_service_account_names=external-secrets \
            bound_service_account_namespaces=external-secrets-system \
            policies=app-secrets-read \
            ttl=1h
          

          # Enable KV secrets engine
          vault secrets enable -path=secret kv-v2 2>/dev/null || echo "KV engine already enabled"
          
          # Create sample secret (replace with actual values)
          vault kv put secret/stripe api-key="sk_test_sample_key"
          
          # Create DefectDojo secrets
          vault kv put secret/defectdojo \
            django-secret-key="$(head -c 50 /dev/urandom | base64 | tr -d '\n')" \
            database-password="$(head -c 32 /dev/urandom | base64 | tr -d '\n')" \
            redis-password="$(head -c 32 /dev/urandom | base64 | tr -d '\n')" \
            admin-password="$(head -c 32 /dev/urandom | base64 | tr -d '\n')" \
            credential-aes-key="$(head -c 16 /dev/urandom | hexdump -ve '1/1 "%.2x"')" \
            metrics-auth-password="$(head -c 24 /dev/urandom | base64 | tr -d '\n')"
          
          # Output admin password for retrieval
          ADMIN_PASS=$(vault kv get -field=admin-password secret/defectdojo)
          echo "DefectDojo admin password: $ADMIN_PASS"
          
          echo "Vault configuration completed"